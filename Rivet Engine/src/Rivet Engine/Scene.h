#ifndef Scene_H
#define Scene_H

#include "AlarmManager.h"
#include "CameraManager.h"
#include "CollisionManager.h"
#include "DrawManager.h"
#include "KeyboardManager.h"
#include "UpdateManager.h"

#include "SceneRegistrationBroker.h"

class Skybox;
class SpawnComponent;

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \class	Scene
///
/// \brief	A game scene which holds several objects and handles their functionality.
///
/// \author	Mike Piunti
/// \date	02/28/2023
////////////////////////////////////////////////////////////////////////////////////////////////////
class Scene {
private:
	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \typedef	std::list<GameObject*> ObjectList
	///
	/// \brief	Defines an alias representing a list of spawnable objects in the scene.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	typedef std::list<SpawnComponent*> SpawnList;

public:
	friend class SceneAttorney;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \typedef	SpawnList::iterator SpawnListRef
	///
	/// \brief	Defines an alias representing storage list references for spawnable objects.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	typedef SpawnList::iterator SpawnListRef;

	Scene() = default;
	Scene(const Scene&) = delete;
	Scene& operator=(const Scene&) = delete;
	virtual ~Scene();

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \fn	virtual void Scene::Initialize() = 0;
	///
	/// \brief	Runs one-time operations needed for the scene to be used.
	/// 		Users implement this function in their derived scenes.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	virtual void Initialize() = 0;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \fn	virtual void Scene::Terminate() = 0;
	///
	/// \brief	Terminates the scene and performs cleanup.
	/// 		Users implement this function in their derived scenes.
	/////////////////////////////////////////////////////////////////////////////////////////////////
	virtual void Terminate() = 0;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \fn	Camera* Scene::GetCurrent3DCamera();
	///
	/// \brief	Gets the current 3D camera used by the scene for rendering objects.
	///
	/// \returns	The current camera.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	Camera* GetCurrent3DCamera();

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \fn	void Scene::SetCurrent3DCamera(Camera* c);
	///
	/// \brief	Sets the current 3D camera for rendering objects in the scene.
	///
	/// \param	c	The new camera to use for rendering.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	void SetCurrent3DCamera(Camera* c);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \fn	Camera* Scene::GetCurrent2DCamera();
	///
	/// \brief	Gets the current 2D camera used by the scene for rendering sprites.
	///
	/// \returns	The current camera.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	Camera* GetCurrent2DCamera();

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \fn	void Scene::SetCurrent2DCamera(Camera* c);
	///
	/// \brief	Sets the current 2D camera for rendering sprites in the scene.
	///
	/// \param	c	The new camera to use for rendering.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	void SetCurrent2DCamera(Camera* c);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \fn	void Scene::Update();
	///
	/// \brief	Handles CPU-side operations for each game object in the scene.
	/// 		This includes updates, alarms, registry, input, and collision.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	void Update();

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \fn	void Scene::Draw();
	///
	/// \brief	Renders each game object in the scene.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	void Draw();

private:
	/// \brief	Alarm handler.
	AlarmManager alarmMan;

	/// \brief	Camera manager.
	CameraManager camMan;

	/// \brief	Collision handler.
	CollisionManager colMan;

	/// \brief	Manager for draw events.
	DrawManager drawMan;

	/// \brief	Handler for keyboard events.
	KeyboardManager keyMan;

	/// \brief	Handler for update events.
	UpdateManager upMan;

	/// \brief	The scene registration broker. Used to prevent adding to lists during an update loop.
	SceneRegistrationBroker regBroker;

	/// \brief	The list of game objects in the scene.
	SpawnList list;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \fn	UpdateManager::StorageListRef Scene::Register(UpdateComponent* up);
	///
	/// \brief	Registers an object for update handling.
	///
	/// \param	up	The game object to update each frame.
	///
	/// \returns	A reference to the object's location in the storage list for efficient deletion.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	UpdateManager::StorageListRef Register(UpdateComponent* up);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \fn	DrawManager::StorageListRef Scene::Register(DrawComponent* dr);
	///
	/// \brief	Registers an object for rendering.
	///
	/// \param	up	The game object to render each frame.
	///
	/// \returns	A reference to the object's location in the storage list for efficient deletion.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	DrawManager::StorageListRef Register(DrawComponent* dr);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \fn	AlarmManager::TimelineRef Scene::Register(AlarmComponent* al);
	///
	/// \brief	Sets an alarm for a given object.
	///
	/// \param	al	The object to modify when the alarm triggers.
	///
	/// \returns	A reference to the alarm on the timeline for efficient deletion, should an alarm be canceled.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	AlarmManager::TimelineRef Register(AlarmComponent* al);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \fn	KeyboardManager::InputListRef Scene::Register(InputComponent* in);
	///
	/// \brief	Registers a given object to respond to the given input event.
	///
	/// \param	in	The object responding to input.
	///
	/// \returns	A reference to the object's location in the input event's list for efficient deletion.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	KeyboardManager::InputListRef Register(InputComponent* in);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \fn	SpawnListRef Scene::Register(SpawnComponent* sc);
	///
	/// \brief	Registers the given object to the scene.
	///
	/// \param go	The game object to register.
	///
	/// \returns	A reference to the object's location in the storage list for efficient deletion.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	SpawnListRef Register(SpawnComponent* sc);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \fn	void Scene::Deregister(UpdateComponent* up);
	///
	/// \brief	Deregisters the given object for update handling.
	///
	/// \param	up	The game object to stop updating each frame.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	void Deregister(UpdateComponent* up);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \fn	void Scene::Deregister(DrawComponent* dr);
	///
	/// \brief	Deregisters this object for rendering.
	///
	/// \param	dr	The game object to stop updating each frame.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	void Deregister(DrawComponent* dr);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \fn	void Scene::Deregister(AlarmComponent* al);
	///
	/// \brief	Deregisters the given alarm for the given object.
	///
	/// \param	al	The object whose alarm to cancel.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	void Deregister(AlarmComponent* al);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \fn	void Scene::Deregister(InputComponent* in);
	///
	/// \brief	Deregisters the given object from responding to the given input event.
	///
	/// \param	in	The object to stop responding to the input event.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	void Deregister(InputComponent* in);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \fn	void Scene::Deregister(SpawnComponent* sc);
	///
	/// \brief	Deregisters the given object from the scene.
	///
	/// \param	go	The game object to deregister.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	void Deregister(SpawnComponent* sc);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \fn	void Scene::SubmitCommand(Command* c);
	///
	/// \brief	Submits a command for processing. This avoids adding to a list during an update loop.
	///
	/// \param	c	The object command to process.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	void SubmitCommand(Command* c);

protected:
	/// \brief	The terrain to include in this scene.
	Terrain* terrain;

	/// \brief	The skybox to include in this scene.
	Skybox* skybox;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \fn	template<typename C1, typename C2> void Scene::SetCollisionPair()
	///
	/// \brief	Sets a pair of object types to allow collisions between objects of each type.
	///
	/// \tparam	C1	The type of the first object.
	/// \tparam	C2	The type of the second object.
	/// 			
	/// If C1 and C2 are the same type, use SetCollisionSelf() instead.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename C1, typename C2>
	void SetCollisionPair() {
		colMan.SetCollisionPair<C1, C2>();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \fn	template<typename C> void Scene::SetCollisionSelf()
	///
	/// \brief	Sets an object type to allow collisions between different objects of that same type.
	///
	/// \tparam	C	The type of the object.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename C>
	void SetCollisionSelf() {
		colMan.SetCollisionSelf<C>();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \fn	template<typename C> void Scene::SetCollisionTerrain()
	///
	/// \brief	Sets an object type to allow collision with the terrain.
	///
	/// \tparam	C	The type of the object.
	////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename C>
	void SetCollisionTerrain() {
		colMan.SetCollisionTerrain<C>(terrain);
	}
};

#endif
